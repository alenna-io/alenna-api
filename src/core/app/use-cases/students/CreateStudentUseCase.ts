// Todo: replace prisma with repositories
import { IStudentRepository } from '../../../adapters_interface/repositories';
import { Student, CertificationType, StudentBillingConfig, StudentScholarship } from '../../../domain/entities';
import { CreateStudentInput } from '../../dtos';
import { PrismaClient } from '@prisma/client';
import { randomUUID } from 'crypto';
import { clerkService } from '../../../frameworks/services/ClerkService';
import { IStudentBillingConfigRepository, IStudentScholarshipRepository } from '../../../adapters_interface/repositories';

const prisma = new PrismaClient();

export class CreateStudentUseCase {
  constructor(
    private studentRepository: IStudentRepository,
    private studentBillingConfigRepository: IStudentBillingConfigRepository,
    private studentScholarshipRepository: IStudentScholarshipRepository
  ) { }

  async execute(input: CreateStudentInput, schoolId: string): Promise<Student> {
    // 1. Check student limit if school has one set
    const school = await prisma.school.findUnique({
      where: { id: schoolId },
      select: { userLimit: true },
    });

    if (school?.userLimit) {
      const currentStudentCount = await prisma.student.count({
        where: {
          schoolId,
          deletedAt: null,
        },
      });

      if (currentStudentCount >= school.userLimit) {
        throw new Error(`Se ha alcanzado el límite de estudiantes permitidos (${school.userLimit}). No se pueden crear más estudiantes.`);
      }
    }

    // 2. Get STUDENT role
    const studentRole = await prisma.role.findFirst({
      where: { name: 'STUDENT', schoolId: null },
    });

    if (!studentRole) {
      throw new Error('STUDENT role not found in system');
    }

    // 3. Ensure email is not already in use
    const existingUser = await prisma.user.findUnique({
      where: { email: input.email },
    });

    if (existingUser) {
      throw new Error('Ya existe un usuario con este correo electrónico');
    }

    // 3. Create Clerk account for student
    let clerkId: string;
    try {
      clerkId = await clerkService.createUser({
        email: input.email,
        firstName: input.firstName,
        lastName: input.lastName,
        skipEmailVerification: false,
      });
    } catch (clerkError: any) {
      console.error('Error creating Clerk account for student:', clerkError);
      const clerkMessage =
        clerkError?.errors?.[0]?.longMessage ||
        clerkError?.message ||
        'Error creating student account in Clerk';
      throw new Error(clerkMessage);
    }

    // 4. Create User account for student in database
    const userId = randomUUID();
    const user = await prisma.user.create({
      data: {
        id: userId,
        createdPassword: false,
        clerkId,
        email: input.email,
        firstName: input.firstName,
        lastName: input.lastName,
        phone: input.phone || null,
        streetAddress: input.streetAddress || null,
        city: input.city || null,
        state: input.state || null,
        country: input.country || null,
        zipCode: input.zipCode || null,
        schoolId,
      },
    });

    // 5. Assign STUDENT role
    await prisma.userRole.create({
      data: {
        id: randomUUID(),
        userId: user.id,
        roleId: studentRole.id,
      },
    });

    // 6. Calculate age from birthDate
    const birthDate = new Date(input.birthDate);
    const today = new Date();
    let age = today.getFullYear() - birthDate.getFullYear();
    const monthDiff = today.getMonth() - birthDate.getMonth();
    if (monthDiff < 0 || (monthDiff === 0 && today.getDate() < birthDate.getDate())) {
      age--;
    }

    // 7. Create Student entity (using data from input + calculated age)
    const student = Student.create({
      id: '', // Will be generated by database
      firstName: input.firstName,
      lastName: input.lastName,
      age, // Calculated from birthDate
      birthDate,
      certificationTypeId: input.certificationTypeId,
      certificationType: new CertificationType(input.certificationTypeId, '', schoolId), // Will be populated by repository
      graduationDate: new Date(input.graduationDate),
      schoolId,
      isLeveled: input.isLeveled || false,
      expectedLevel: input.expectedLevel,
      currentLevel: input.currentLevel,
      parents: [],
    });

    // 8. Create Student record linked to User
    const createdStudent = await this.studentRepository.createWithUser(student, user.id);

    // 9. Create parent users and link them to the student (at least 1 required)
    if (!input.parents || input.parents.length === 0) {
      throw new Error('At least one parent is required when creating a student');
    }

    if (input.parents.length > 2) {
      throw new Error('Maximum two parents allowed per student');
    }

    // Get PARENT role
    const parentRole = await prisma.role.findFirst({
      where: { name: 'PARENT', schoolId: null },
    });

    if (!parentRole) {
      throw new Error('PARENT role not found in system');
    }

    // Create parent users and link them to the student
    for (const parentData of input.parents) {
      const parentUserId = randomUUID();
      // Parent email is required and should always be a real email (validated in DTO)
      const parentEmail = parentData.email;

      // Check if parent email already exists
      const existingParent = await prisma.user.findUnique({
        where: { email: parentEmail },
      });

      let parentUser;
      if (existingParent) {
        // If parent already exists, use existing user
        parentUser = existingParent;
      } else {
        // Create Clerk account for parent (they have a real email)
        let clerkId: string | null = null;
        try {
          clerkId = await clerkService.createUser({
            email: parentEmail,
            firstName: parentData.firstName,
            lastName: parentData.lastName,
            skipEmailVerification: false, // Send invitation email
          });
        } catch (clerkError: any) {
          console.error('Error creating Clerk account for parent:', clerkError);
          // Continue with placeholder if Clerk creation fails - user can be created later
          clerkId = `parent_${parentUserId}_clerk`;
        }

        // Create new parent user in database
        parentUser = await prisma.user.create({
          data: {
            id: parentUserId,
            clerkId,
            email: parentEmail,
            firstName: parentData.firstName,
            lastName: parentData.lastName,
            phone: parentData.phone,
            schoolId,
            createdPassword: false,
          },
        });

        // Assign PARENT role if not already assigned
        const hasParentRole = await prisma.userRole.findFirst({
          where: {
            userId: parentUser.id,
            roleId: parentRole.id,
          },
        });

        if (!hasParentRole) {
          await prisma.userRole.create({
            data: {
              id: randomUUID(),
              userId: parentUser.id,
              roleId: parentRole.id,
            },
          });
        }
      }

      // Link parent to student
      const existingLink = await prisma.userStudent.findFirst({
        where: {
          userId: parentUser.id,
          studentId: createdStudent.id,
        },
      });

      if (!existingLink) {
        await prisma.userStudent.create({
          data: {
            id: randomUUID(),
            userId: parentUser.id,
            studentId: createdStudent.id,
            relationship: parentData.relationship || 'Parent',
          },
        });
      }
    }

    // 10. Create billing config for student
    const billingConfig = StudentBillingConfig.create({
      id: randomUUID(),
      studentId: createdStudent.id,
      requiresTaxableInvoice: false,
    });
    await this.studentBillingConfigRepository.create(billingConfig);

    // 11. Create scholarship for student
    const scholarship = StudentScholarship.create({
      id: randomUUID(),
      studentId: createdStudent.id,
      tuitionTypeId: null,
      scholarshipType: 'percentage',
      scholarshipValue: 0
    });
    await this.studentScholarshipRepository.create(scholarship);

    // 12. Return student with updated parents list
    const studentWithParents = await this.studentRepository.findById(createdStudent.id, schoolId);
    return studentWithParents || createdStudent;
  }
}

